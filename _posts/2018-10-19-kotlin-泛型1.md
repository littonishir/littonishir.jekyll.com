---
layout:     post
title:      "kotlin-泛型1"
subtitle:   "君见,目之所及."
date:       2018-10-19 17:32:21
author:     "ishir"
header-img: "img/2018-08-10-ishir9.jpg"
header-mask: 0.5
catalog:    true
tags:
    - kotlin
---
**<font size="5">  </font>**
<!--上标：º ¹ ² ³ ⁴⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽ ⁾ ⁿ ′ ½下标：₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎
[<font size="2" color="#006666">包级函数</font>](#package)<p id = "package"></p>-->

## 泛型

### 什么是泛型？

* 泛化的类型或者说类型的抽象
* 很多时候我们并不关心它是什么
* 而关心它能做什么，这就是泛型要解决的问题。

### 如何为函数声明泛型

- 为函数声明泛型，泛型要放在函数名之前。
	
```kotlin
   　fun <T : Comparable<T>> maxOf(a: T, b: T): T {
        return if (a > b) a else b
    }
```


### 如何为类声明泛型

- 为类声明泛型，泛型要放在类名之后

```kotlin
	class showText<T>(val i: T,  val j: T) {
    	override fun toString(): String {
        	return "$i,$j"
    	}
```

#### 泛型约束

- \<T : Comparable<T>>

- :冒号之后指定的类型是上界，泛型T只能是Comparable<T>的子类。

- 若没有声明,默认的上界是Any? 在尖括号中只能指定一个上界.如果同一类型参数需要多个上界，我们需要一个单独的where子句

```kotlin
 fun<T> maxof(a:T,b:T):T
    where T:Comparable<T>,T:Cloneable {
        return if (a>b) a else b
    }
```

---

#### 泛型的实现机制

- 何为真泛型（C#）
	- 真泛型编译前变异后，泛型都存在
- 何为伪泛型（Java，Kotlin）
	- 伪泛型只存在编译之前，编译之后就随风而去了

##### Kotlin对于真泛型的部分实现

- 使用 inline（内联）关键字标记方法 
- 使用 Reifild（具体化）关键字标记泛型

> 注意泛型具体化必须使用inline标记

```kt
   @Test
    fun addition_isCorrect() {
        Generic<Int>()
    }
    
    inline fun <reified T>Generic(){
        println(T::class.java)
    }
```

输出结果

> class java.lang.Integer


### 型变

型变点

* 协变点 
	* 泛型参数：返回值类型
	* 一提到协变你就应该想到类型是只读的
	* 对于谁只读呢？
	* 对于泛型参数类型对应的变量时只读的
* 逆变点 
	* 泛型参数：入参类型
	* 一提到逆变你就应该想到类型是只写的
* 不变点 
	* <font size="3" color="#006666">T</font>
	* 类型是可读写的
* 型变点违规
	* 使用 @UnsafeVariance 标注
	
#### 泛型实参的继承关系对泛型类型的影响


* 协变(out)：泛型类型与实参的继承关系相同
	* 如果一个类型的泛型参数是协变的，这个类型的继承关系与泛型参数的继承关系是一致的。

* 逆变(in) ：泛型类型与实参的继承关系相反
	* 如果一个类型的泛型参数是逆变的，这个类型的继承关系与泛型参数的继承关系是相反的。
 

```kotlin
   		/**
         * 协变
         * List<Number>是List<Int>的父类
         * 协变(out)：泛型类型与实参的继承关系相同
         */
        var list:List<Number> = listOf(1,2,3)


        /**
         * 逆变
         * Comparable<Int>居然是Comparable<Any>的父类我没有瞎吧？
         * 你没有瞎，可是为什么会这样呢？
         */
        val intComparable : Comparable<Int> = object : Comparable<Any>{
            override fun compareTo(other: Any): Int {
                return 0
            }
        }

        /**
         * 我们看下实现，Comparable<in T> 
         * 逆变(in) ：泛型类型与实参的继承关系相反
         * 这就可以解释通了
         */
        public interface Comparable<in T> {
            public operator fun compareTo(other: T): Int
        }
```

#### 星投影

有时你对类型参数一无所知，但任然希望以安全的方式使用它。星投影就是你了。

```kotlin

        var list:List<*> = listOf(1,2,3)

```

注意需要泛型实参时不能使用星投影

```kotlin
	//这样用可以吗当然不可以!!!!
    hello<*>()
    fun <T> hello() {}
```










